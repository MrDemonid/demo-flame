package mr.demonid.jukebox;


import mr.demonid.graphics.ScreenBuffer;
import mr.demonid.graphics.VGAPalette;

import java.util.Random;
import static java.lang.Math.random;



public class JukeBox {

    private final static int MAX_STARS = 1000;
    private final static int MAX_DISTANCE = 500;

    byte[] gamePalette = {
            0x00, 0x00, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x2A, 0x00, 0x00, 0x2A, 0x2A, 0x2A, 0x00, 0x00, 0x2A,
            0x00, 0x2A, 0x2A, 0x15, 0x00, 0x2A, 0x2A, 0x2A, 0x15, 0x15, 0x15, 0x15, 0x15, 0x3F, 0x15, 0x3F,
            0x15, 0x15, 0x3F, 0x3F, 0x3F, 0x15, 0x15, 0x3F, 0x15, 0x3F, 0x3F, 0x3F, 0x15, 0x3F, 0x3F, 0x3F,
            0x00, 0x00, 0x00, 0x05, 0x05, 0x05, 0x08, 0x08, 0x08, 0x0B, 0x0B, 0x0B, 0x0E, 0x0E, 0x0E, 0x11,
            0x11, 0x11, 0x14, 0x14, 0x14, 0x18, 0x18, 0x18, 0x1C, 0x1C, 0x1C, 0x20, 0x20, 0x20, 0x24, 0x24,
            0x24, 0x28, 0x28, 0x28, 0x2D, 0x2D, 0x2D, 0x32, 0x32, 0x32, 0x38, 0x38, 0x38, 0x3F, 0x3F, 0x3F,
            0x00, 0x00, 0x3F, 0x10, 0x00, 0x3F, 0x1F, 0x00, 0x3F, 0x2F, 0x00, 0x3F, 0x3F, 0x00, 0x3F, 0x3F,
            0x00, 0x2F, 0x3F, 0x00, 0x1F, 0x3F, 0x00, 0x10, 0x3F, 0x00, 0x00, 0x3F, 0x10, 0x00, 0x3F, 0x1F,
            0x00, 0x3F, 0x2F, 0x00, 0x3F, 0x3F, 0x00, 0x2F, 0x3F, 0x00, 0x1F, 0x3F, 0x00, 0x10, 0x3F, 0x00,
            0x00, 0x3F, 0x00, 0x00, 0x3F, 0x10, 0x00, 0x3F, 0x1F, 0x00, 0x3F, 0x2F, 0x00, 0x3F, 0x3F, 0x00,
            0x2F, 0x3F, 0x00, 0x1F, 0x3F, 0x00, 0x10, 0x3F, 0x1F, 0x1F, 0x3F, 0x27, 0x1F, 0x3F, 0x2F, 0x1F,
            0x3F, 0x37, 0x1F, 0x3F, 0x3F, 0x1F, 0x3F, 0x3F, 0x1F, 0x37, 0x3F, 0x1F, 0x2F, 0x3F, 0x1F, 0x27,
            0x3F, 0x1F, 0x1F, 0x3F, 0x27, 0x1F, 0x3F, 0x2F, 0x1F, 0x3F, 0x37, 0x1F, 0x3F, 0x3F, 0x1F, 0x37,
            0x3F, 0x1F, 0x2F, 0x3F, 0x1F, 0x27, 0x3F, 0x1F, 0x1F, 0x3F, 0x1F, 0x1F, 0x3F, 0x27, 0x1F, 0x3F,
            0x2F, 0x1F, 0x3F, 0x37, 0x1F, 0x3F, 0x3F, 0x1F, 0x37, 0x3F, 0x1F, 0x2F, 0x3F, 0x1F, 0x27, 0x3F,
            0x2D, 0x2D, 0x3F, 0x31, 0x2D, 0x3F, 0x36, 0x2D, 0x3F, 0x3A, 0x2D, 0x3F, 0x3F, 0x2D, 0x3F, 0x3F,
            0x2D, 0x3A, 0x3F, 0x2D, 0x36, 0x3F, 0x2D, 0x31, 0x3F, 0x2D, 0x2D, 0x3F, 0x31, 0x2D, 0x3F, 0x36,
            0x2D, 0x3F, 0x3A, 0x2D, 0x3F, 0x3F, 0x2D, 0x3A, 0x3F, 0x2D, 0x36, 0x3F, 0x2D, 0x31, 0x3F, 0x2D,
            0x2D, 0x3F, 0x2D, 0x2D, 0x3F, 0x31, 0x2D, 0x3F, 0x36, 0x2D, 0x3F, 0x3A, 0x2D, 0x3F, 0x3F, 0x2D,
            0x3A, 0x3F, 0x2D, 0x36, 0x3F, 0x2D, 0x31, 0x3F, 0x00, 0x00, 0x1C, 0x07, 0x00, 0x1C, 0x0E, 0x00,
            0x1C, 0x15, 0x00, 0x1C, 0x1C, 0x00, 0x1C, 0x1C, 0x00, 0x15, 0x1C, 0x00, 0x0E, 0x1C, 0x00, 0x07,
            0x1C, 0x00, 0x00, 0x1C, 0x07, 0x00, 0x1C, 0x0E, 0x00, 0x1C, 0x15, 0x00, 0x1C, 0x1C, 0x00, 0x15,
            0x1C, 0x00, 0x0E, 0x1C, 0x00, 0x07, 0x1C, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x1C, 0x07, 0x00, 0x1C,
            0x0E, 0x00, 0x1C, 0x15, 0x00, 0x1C, 0x1C, 0x00, 0x15, 0x1C, 0x00, 0x0E, 0x1C, 0x00, 0x07, 0x1C,
            0x0E, 0x0E, 0x1C, 0x11, 0x0E, 0x1C, 0x15, 0x0E, 0x1C, 0x18, 0x0E, 0x1C, 0x1C, 0x0E, 0x1C, 0x1C,
            0x0E, 0x18, 0x1C, 0x0E, 0x15, 0x1C, 0x0E, 0x11, 0x1C, 0x0E, 0x0E, 0x1C, 0x11, 0x0E, 0x1C, 0x15,
            0x0E, 0x1C, 0x18, 0x0E, 0x1C, 0x1C, 0x0E, 0x18, 0x1C, 0x0E, 0x15, 0x1C, 0x0E, 0x11, 0x1C, 0x0E,
            0x0E, 0x1C, 0x0E, 0x0E, 0x1C, 0x11, 0x0E, 0x1C, 0x15, 0x0E, 0x1C, 0x18, 0x0E, 0x1C, 0x1C, 0x0E,
            0x18, 0x1C, 0x0E, 0x15, 0x1C, 0x0E, 0x11, 0x1C, 0x14, 0x14, 0x1C, 0x16, 0x14, 0x1C, 0x18, 0x14,
            0x1C, 0x1A, 0x14, 0x1C, 0x1C, 0x14, 0x1C, 0x1C, 0x14, 0x1A, 0x1C, 0x14, 0x18, 0x1C, 0x14, 0x16,
            0x1C, 0x14, 0x14, 0x1C, 0x16, 0x14, 0x1C, 0x18, 0x14, 0x1C, 0x1A, 0x14, 0x1C, 0x1C, 0x14, 0x1A,
            0x1C, 0x14, 0x18, 0x1C, 0x14, 0x16, 0x1C, 0x14, 0x14, 0x1C, 0x14, 0x14, 0x1C, 0x16, 0x14, 0x1C,
            0x18, 0x14, 0x1C, 0x1A, 0x14, 0x1C, 0x1C, 0x14, 0x1A, 0x1C, 0x14, 0x18, 0x1C, 0x14, 0x16, 0x1C,
            0x00, 0x00, 0x10, 0x04, 0x00, 0x10, 0x08, 0x00, 0x10, 0x0C, 0x00, 0x10, 0x10, 0x00, 0x10, 0x10,
            0x00, 0x0C, 0x10, 0x00, 0x08, 0x10, 0x00, 0x04, 0x10, 0x00, 0x00, 0x10, 0x04, 0x00, 0x10, 0x08,
            0x00, 0x10, 0x0C, 0x00, 0x10, 0x10, 0x00, 0x0C, 0x10, 0x00, 0x08, 0x10, 0x00, 0x04, 0x10, 0x00,
            0x00, 0x10, 0x00, 0x00, 0x10, 0x04, 0x00, 0x10, 0x08, 0x00, 0x10, 0x0C, 0x00, 0x10, 0x10, 0x00,
            0x0C, 0x10, 0x00, 0x08, 0x10, 0x00, 0x04, 0x10, 0x08, 0x08, 0x10, 0x0A, 0x08, 0x10, 0x0C, 0x08,
            0x10, 0x0E, 0x08, 0x10, 0x10, 0x08, 0x10, 0x10, 0x08, 0x0E, 0x10, 0x08, 0x0C, 0x10, 0x08, 0x0A,
            0x10, 0x08, 0x08, 0x10, 0x0A, 0x08, 0x10, 0x0C, 0x08, 0x10, 0x0E, 0x08, 0x10, 0x10, 0x08, 0x0E,
            0x10, 0x08, 0x0C, 0x10, 0x08, 0x0A, 0x10, 0x08, 0x08, 0x10, 0x08, 0x08, 0x10, 0x0A, 0x08, 0x10,
            0x0C, 0x08, 0x10, 0x0E, 0x08, 0x10, 0x10, 0x08, 0x0E, 0x10, 0x08, 0x0C, 0x10, 0x08, 0x0A, 0x10,
            0x0B, 0x0B, 0x10, 0x0C, 0x0B, 0x10, 0x0D, 0x0B, 0x10, 0x0F, 0x0B, 0x10, 0x10, 0x0B, 0x10, 0x10,
            0x0B, 0x0F, 0x10, 0x0B, 0x0D, 0x10, 0x0B, 0x0C, 0x10, 0x0B, 0x0B, 0x10, 0x0C, 0x0B, 0x10, 0x0D,
            0x0B, 0x10, 0x0F, 0x0B, 0x10, 0x10, 0x0B, 0x0F, 0x10, 0x0B, 0x0D, 0x10, 0x0B, 0x0C, 0x10, 0x0B,
            0x0B, 0x10, 0x0B, 0x0B, 0x10, 0x0C, 0x0B, 0x10, 0x0D, 0x0B, 0x10, 0x0F, 0x0B, 0x10, 0x10, 0x0B,
            0x0F, 0x10, 0x0B, 0x0D, 0x10, 0x0B, 0x0C, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};




    Random rand = new Random(System.currentTimeMillis());


    float Angle;
    float AngleIncrement;   // приращение угла на каждом шаге
    float AngleVelocity;    // приращение инкремента

    int   intAngle;         //
    int   incrIntAngle;

    int   warpSpeed;        // скорость приближения звезд
    int   warpVelocity;     // приращение скорости приближения

    int   changeTicks;      // отсчитанное время до смены функции генерации звезд
    int   changeTime;       // время до смены функции генерации звезд

    boolean isChangeFunc;   // флаг разрешения смены функции генерации звезд
                            //     0 - смена функции запрещена
                            //     1 - разрешена
    int nGenFunc;           // номер текущей функции генерации звезд

    char  baseColor;        // цвет новоиспеченных звезд
    char  colorMethod;      // определяет методику назначения цвета звездам
                            //     0: color = baseColor + ((Z / 16) & 0x1F)
                            //     1: color = Z / 2
    private VGAPalette palette;


    private final Star[] stars = new Star[MAX_STARS];;


    public JukeBox() {
        palette = new VGAPalette(gamePalette);
        starInitialize();
    }

    private void starInitialize() {
        isChangeFunc = false;  // разрешаем смену функций генерации звезд
        starInitStars();
        starsReset();
        starSetFunc(2);
    }

    private void starSetFunc(int func) {
        changeTicks = 0;
        changeTime = rand.nextInt(1000);

        if (func <= 0)
        {
            //nGenFunc = random(15);
            nGenFunc = rand.nextInt(6);     // 0..5
        } else {
            if (func > 14)
                func = 14;
            nGenFunc = func;
        }
        if (nGenFunc == 1)
            AngleIncrement = 0.1f;
        if (AngleIncrement > 2.2f)
            AngleIncrement = 0.1f;
    }

    /*
        Сброс настроек генератора звезд
     */
    private void starsReset() {
        intAngle = 1;
        incrIntAngle = 1;
        Angle = 0.0f;
        AngleIncrement = 0.1f;
        AngleVelocity = 0.0001f;
        baseColor = 32;
        warpSpeed = 2;
        warpVelocity = 0;
    }

    /*
        Инициализация массива звезд
     */
    private void starInitStars() {
        for (int i = 0; i < MAX_STARS; i++) {
            stars[i] = new Star(rand.nextInt(64000) - 32000, rand.nextInt(40000) - 20000, i+1, palette);
        }
    }

    /*
        Перерождение ушедшей с поля зрения звезды - просто даем новые координаты.
    */
    void genNewCoord(int index)
    {
        double newX;
        double newY;

        if (nGenFunc == 0)
        {
            newX = rand.nextInt(64000) - 32000;
            newY = rand.nextInt(40000) - 20000;
        } else {
            Angle += AngleIncrement;
            switch (nGenFunc)
            {
                case 1:
                    newX = Math.cos(Angle / 30.0f) * 20000.0f;
                    newY = rand.nextInt(40000) - 20000;
                    break;
                case 2:
                    newX = Math.sin(Angle) * 20000.0f;
                    newY = Math.cos(Angle) * 20000.0f;
                    break;
                case 3:
                    newX = (Math.sin(Angle * 15.0f) * 100.0f) * ((int)(Angle / 6.0f) % 200);
                    newY = (Math.cos(Angle * 15.0f) * 100.0f) * ((int)(Angle / 6.0f) % 200);
                    break;

                case 4:
                    newX = Math.cos(Angle / 60.0f) * 20000.0f;
                    newY = (Math.sin(Angle) * (long)(Math.cos(Angle / 200.0f) * 300.0f)) * 100.0f;
                    break;

                case 5:
                    newX = Math.cos(Angle / 2.0f) * 20000.0f;
                    newY = (long)(Math.sin(Angle / 200.0f) * 300.0f) * Math.cos(Angle) * 100.0f;
                    break;

                default:
                    newX = rand.nextInt(64000) - 32000;
                    newY = rand.nextInt(40000) - 20000;
            } // switch
        }
        stars[index].setZ(MAX_DISTANCE);
        stars[index].setX((int) newX);
        stars[index].setY((int) newY);
    }

    /**
     * Перерисовка звезд
     */
    public void render(ScreenBuffer buffer) {
        int col;

        int width = buffer.getWidth();
        int height = buffer.getHeight();

        colorMethod = 0;
        warpSpeed += warpVelocity;

        buffer.clear();

        for (int i = 0; i < MAX_STARS; i++)
        {
            Star star = stars[i];

            // вычисляем новые координаты
            int nz = star.getZ();
            int nx = star.getX() / nz + (width / 2);     // si
            int ny = star.getY() / nz + (height / 2);
            nz -= warpSpeed;
            if (nz <= 1 || ny <= 1 || ny > (height-3) || nx <= 0 || nx > (width-3))
            {
                // звезда вышла за пределы экрана, создаем новую
                genNewCoord(i);

            } else {
                // перемещаем звезду на новое место
                star.setScreenX(nx);
                star.setScreenY(ny);
                star.setZ(nz);
                col = baseColor + ((nz / 16) & 0x1F);
//                if (colorMethod != 1)
//                {
//                    col = baseColor + ((nz / 16) & 0x1F);
//                } else {
//                    col = nz / 2;
//                }
                // отрисовываем на новом месте
                star.setColor(col);
                star.render(buffer);
            }
        }
        // не пора ли менять функцию генератора звезд?
        if (isChangeFunc)
        {
            changeTicks++;
            if (changeTicks > changeTime)
                starSetFunc(0);
        }
        //
        if (rand.nextInt(1000) == 1)
        {
            AngleVelocity = (float) (random() * 0.001f - 0.0005f);
        }
        AngleIncrement += AngleVelocity;
    }



}
