package mr.demonid.jukebox;


import mr.demonid.graphics.ScreenBuffer;

import java.awt.event.KeyEvent;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

import static java.lang.Math.*;


public class JukeBox {

    private final static int MAX_STARS = 1000;
    private final static int MAX_DISTANCE = 500;

    byte[] gamePalette = {
            0x00, 0x00, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x2A, 0x00, 0x00, 0x2A, 0x2A, 0x2A, 0x00, 0x00, 0x2A,
            0x00, 0x2A, 0x2A, 0x15, 0x00, 0x2A, 0x2A, 0x2A, 0x15, 0x15, 0x15, 0x15, 0x15, 0x3F, 0x15, 0x3F,
            0x15, 0x15, 0x3F, 0x3F, 0x3F, 0x15, 0x15, 0x3F, 0x15, 0x3F, 0x3F, 0x3F, 0x15, 0x3F, 0x3F, 0x3F,
            0x00, 0x00, 0x00, 0x05, 0x05, 0x05, 0x08, 0x08, 0x08, 0x0B, 0x0B, 0x0B, 0x0E, 0x0E, 0x0E, 0x11,
            0x11, 0x11, 0x14, 0x14, 0x14, 0x18, 0x18, 0x18, 0x1C, 0x1C, 0x1C, 0x20, 0x20, 0x20, 0x24, 0x24,
            0x24, 0x28, 0x28, 0x28, 0x2D, 0x2D, 0x2D, 0x32, 0x32, 0x32, 0x38, 0x38, 0x38, 0x3F, 0x3F, 0x3F,
            0x00, 0x00, 0x3F, 0x10, 0x00, 0x3F, 0x1F, 0x00, 0x3F, 0x2F, 0x00, 0x3F, 0x3F, 0x00, 0x3F, 0x3F,
            0x00, 0x2F, 0x3F, 0x00, 0x1F, 0x3F, 0x00, 0x10, 0x3F, 0x00, 0x00, 0x3F, 0x10, 0x00, 0x3F, 0x1F,
            0x00, 0x3F, 0x2F, 0x00, 0x3F, 0x3F, 0x00, 0x2F, 0x3F, 0x00, 0x1F, 0x3F, 0x00, 0x10, 0x3F, 0x00,
            0x00, 0x3F, 0x00, 0x00, 0x3F, 0x10, 0x00, 0x3F, 0x1F, 0x00, 0x3F, 0x2F, 0x00, 0x3F, 0x3F, 0x00,
            0x2F, 0x3F, 0x00, 0x1F, 0x3F, 0x00, 0x10, 0x3F, 0x1F, 0x1F, 0x3F, 0x27, 0x1F, 0x3F, 0x2F, 0x1F,
            0x3F, 0x37, 0x1F, 0x3F, 0x3F, 0x1F, 0x3F, 0x3F, 0x1F, 0x37, 0x3F, 0x1F, 0x2F, 0x3F, 0x1F, 0x27,
            0x3F, 0x1F, 0x1F, 0x3F, 0x27, 0x1F, 0x3F, 0x2F, 0x1F, 0x3F, 0x37, 0x1F, 0x3F, 0x3F, 0x1F, 0x37,
            0x3F, 0x1F, 0x2F, 0x3F, 0x1F, 0x27, 0x3F, 0x1F, 0x1F, 0x3F, 0x1F, 0x1F, 0x3F, 0x27, 0x1F, 0x3F,
            0x2F, 0x1F, 0x3F, 0x37, 0x1F, 0x3F, 0x3F, 0x1F, 0x37, 0x3F, 0x1F, 0x2F, 0x3F, 0x1F, 0x27, 0x3F,
            0x2D, 0x2D, 0x3F, 0x31, 0x2D, 0x3F, 0x36, 0x2D, 0x3F, 0x3A, 0x2D, 0x3F, 0x3F, 0x2D, 0x3F, 0x3F,
            0x2D, 0x3A, 0x3F, 0x2D, 0x36, 0x3F, 0x2D, 0x31, 0x3F, 0x2D, 0x2D, 0x3F, 0x31, 0x2D, 0x3F, 0x36,
            0x2D, 0x3F, 0x3A, 0x2D, 0x3F, 0x3F, 0x2D, 0x3A, 0x3F, 0x2D, 0x36, 0x3F, 0x2D, 0x31, 0x3F, 0x2D,
            0x2D, 0x3F, 0x2D, 0x2D, 0x3F, 0x31, 0x2D, 0x3F, 0x36, 0x2D, 0x3F, 0x3A, 0x2D, 0x3F, 0x3F, 0x2D,
            0x3A, 0x3F, 0x2D, 0x36, 0x3F, 0x2D, 0x31, 0x3F, 0x00, 0x00, 0x1C, 0x07, 0x00, 0x1C, 0x0E, 0x00,
            0x1C, 0x15, 0x00, 0x1C, 0x1C, 0x00, 0x1C, 0x1C, 0x00, 0x15, 0x1C, 0x00, 0x0E, 0x1C, 0x00, 0x07,
            0x1C, 0x00, 0x00, 0x1C, 0x07, 0x00, 0x1C, 0x0E, 0x00, 0x1C, 0x15, 0x00, 0x1C, 0x1C, 0x00, 0x15,
            0x1C, 0x00, 0x0E, 0x1C, 0x00, 0x07, 0x1C, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x1C, 0x07, 0x00, 0x1C,
            0x0E, 0x00, 0x1C, 0x15, 0x00, 0x1C, 0x1C, 0x00, 0x15, 0x1C, 0x00, 0x0E, 0x1C, 0x00, 0x07, 0x1C,
            0x0E, 0x0E, 0x1C, 0x11, 0x0E, 0x1C, 0x15, 0x0E, 0x1C, 0x18, 0x0E, 0x1C, 0x1C, 0x0E, 0x1C, 0x1C,
            0x0E, 0x18, 0x1C, 0x0E, 0x15, 0x1C, 0x0E, 0x11, 0x1C, 0x0E, 0x0E, 0x1C, 0x11, 0x0E, 0x1C, 0x15,
            0x0E, 0x1C, 0x18, 0x0E, 0x1C, 0x1C, 0x0E, 0x18, 0x1C, 0x0E, 0x15, 0x1C, 0x0E, 0x11, 0x1C, 0x0E,
            0x0E, 0x1C, 0x0E, 0x0E, 0x1C, 0x11, 0x0E, 0x1C, 0x15, 0x0E, 0x1C, 0x18, 0x0E, 0x1C, 0x1C, 0x0E,
            0x18, 0x1C, 0x0E, 0x15, 0x1C, 0x0E, 0x11, 0x1C, 0x14, 0x14, 0x1C, 0x16, 0x14, 0x1C, 0x18, 0x14,
            0x1C, 0x1A, 0x14, 0x1C, 0x1C, 0x14, 0x1C, 0x1C, 0x14, 0x1A, 0x1C, 0x14, 0x18, 0x1C, 0x14, 0x16,
            0x1C, 0x14, 0x14, 0x1C, 0x16, 0x14, 0x1C, 0x18, 0x14, 0x1C, 0x1A, 0x14, 0x1C, 0x1C, 0x14, 0x1A,
            0x1C, 0x14, 0x18, 0x1C, 0x14, 0x16, 0x1C, 0x14, 0x14, 0x1C, 0x14, 0x14, 0x1C, 0x16, 0x14, 0x1C,
            0x18, 0x14, 0x1C, 0x1A, 0x14, 0x1C, 0x1C, 0x14, 0x1A, 0x1C, 0x14, 0x18, 0x1C, 0x14, 0x16, 0x1C,
            0x00, 0x00, 0x10, 0x04, 0x00, 0x10, 0x08, 0x00, 0x10, 0x0C, 0x00, 0x10, 0x10, 0x00, 0x10, 0x10,
            0x00, 0x0C, 0x10, 0x00, 0x08, 0x10, 0x00, 0x04, 0x10, 0x00, 0x00, 0x10, 0x04, 0x00, 0x10, 0x08,
            0x00, 0x10, 0x0C, 0x00, 0x10, 0x10, 0x00, 0x0C, 0x10, 0x00, 0x08, 0x10, 0x00, 0x04, 0x10, 0x00,
            0x00, 0x10, 0x00, 0x00, 0x10, 0x04, 0x00, 0x10, 0x08, 0x00, 0x10, 0x0C, 0x00, 0x10, 0x10, 0x00,
            0x0C, 0x10, 0x00, 0x08, 0x10, 0x00, 0x04, 0x10, 0x08, 0x08, 0x10, 0x0A, 0x08, 0x10, 0x0C, 0x08,
            0x10, 0x0E, 0x08, 0x10, 0x10, 0x08, 0x10, 0x10, 0x08, 0x0E, 0x10, 0x08, 0x0C, 0x10, 0x08, 0x0A,
            0x10, 0x08, 0x08, 0x10, 0x0A, 0x08, 0x10, 0x0C, 0x08, 0x10, 0x0E, 0x08, 0x10, 0x10, 0x08, 0x0E,
            0x10, 0x08, 0x0C, 0x10, 0x08, 0x0A, 0x10, 0x08, 0x08, 0x10, 0x08, 0x08, 0x10, 0x0A, 0x08, 0x10,
            0x0C, 0x08, 0x10, 0x0E, 0x08, 0x10, 0x10, 0x08, 0x0E, 0x10, 0x08, 0x0C, 0x10, 0x08, 0x0A, 0x10,
            0x0B, 0x0B, 0x10, 0x0C, 0x0B, 0x10, 0x0D, 0x0B, 0x10, 0x0F, 0x0B, 0x10, 0x10, 0x0B, 0x10, 0x10,
            0x0B, 0x0F, 0x10, 0x0B, 0x0D, 0x10, 0x0B, 0x0C, 0x10, 0x0B, 0x0B, 0x10, 0x0C, 0x0B, 0x10, 0x0D,
            0x0B, 0x10, 0x0F, 0x0B, 0x10, 0x10, 0x0B, 0x0F, 0x10, 0x0B, 0x0D, 0x10, 0x0B, 0x0C, 0x10, 0x0B,
            0x0B, 0x10, 0x0B, 0x0B, 0x10, 0x0C, 0x0B, 0x10, 0x0D, 0x0B, 0x10, 0x0F, 0x0B, 0x10, 0x10, 0x0B,
            0x0F, 0x10, 0x0B, 0x0D, 0x10, 0x0B, 0x0C, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};


    Random rand = new Random(System.currentTimeMillis());


    private double Angle;
    private double AngleIncrement;   // приращение угла на каждом шаге
    private double AngleVelocity;    // приращение инкремента

    private int Angle2;
    private int Angle2Increment;

    private int warpSpeed;        // скорость приближения звезд
    private int warpVelocity;     // приращение скорости приближения

    private int changeTicks;      // отсчитанное время до смены функции генерации звезд
    private int changeTime;       // время до смены функции генерации звезд

    private boolean isChangeFunc;   // флаг разрешения смены функции генерации звезд
    //     0 - смена функции запрещена
    //     1 - разрешена
    private int nGenFunc;           // номер текущей функции генерации звезд

    private byte baseColor;        // цвет новоиспеченных звезд

    private final List<Star> stars = new ArrayList<>(MAX_STARS);
    //    private final Star[] stars = new Star[MAX_STARS];


    public JukeBox() {
        starInitialize();
    }


    public byte[] getGamePalette() {
        return gamePalette;
    }

    private void starInitialize() {
        isChangeFunc = false;        // разрешаем смену функций генерации звезд
//        isChangeFunc = true;        // разрешаем смену функций генерации звезд
        starsReset();
        starInitStars();
        starSetFunc(0);
    }

    private void starSetFunc(int func) {
        changeTicks = 0;
        changeTime = rand.nextInt(1000);

        if (func <= 0) {
            nGenFunc = rand.nextInt(13);     // 0..10
        } else {
            nGenFunc = min(func, 12);
        }
        if (nGenFunc == 1)
            AngleIncrement = 0.1f;
        if (AngleIncrement > 2.2f)
            AngleIncrement = 0.1f;
    }

    /*
        Сброс настроек генератора звезд
     */
    private void starsReset() {
        Angle = 0.0f;
        AngleIncrement = 0.1f;
        AngleVelocity = 0.0001f;
        Angle2 = 0;
        Angle2Increment = 1;
        baseColor = 32;
        warpSpeed = 2;
        warpVelocity = 0;
    }

    /*
        Инициализация массива звезд
     */
    private void starInitStars() {
        for (int i = 0; i < MAX_STARS; i++) {
            stars.add(new Star(rand.nextInt(64000) - 32000, rand.nextInt(40000) - 20000, i + 1));
        }
    }

    /*
        Перерождение ушедшей с поля зрения звезды - просто даем новые координаты.
    */
    void genNewCoord(Star star) {
        short newX = 0;
        short newY = 0;


        if (nGenFunc == 0) {
            newX = (short) (rand.nextInt(64000) - 32000);
            newY = (short) (rand.nextInt(40000) - 20000);
        } else {
            Angle += AngleIncrement;
            switch (nGenFunc) {
                case 1:
                    newX = (short) (cos(Angle / 30.0) * 20000.0);
                    newY = (short) (rand.nextInt(40000) - 20000.0);
                    break;
                case 2:
                    newX = (short) (sin(Angle) * 20000.0);
                    newY = (short) (cos(Angle) * 20000.0);
                    break;
                case 3:
                    newX = (short) (((int)(sin(Angle * 15.0) * 100.0)) * (((int) (Angle / 6.0)) % 200));
                    newY = (short) (((int)(cos(Angle * 15.0) * 100.0)) * (((int) (Angle / 6.0)) % 200));
                    break;
                case 4:
                    newX = (short) (cos(Angle / 60.0) * 20000.0);
                    newY = (short) (sin(Angle) * ((int)(cos(Angle / 200.0) * 300.0)) * 100.0);
                    break;
                case 5:
//                    newX = (short) (cos(Angle / 2.0f) * 20000.0f);
//                    newY = (short) ((int)(cos(Angle / 200.0f) * 300.0f) * sin(Angle) * 100.0f);
                    newX = (short) (cos(Angle / 2.0f) * 20000.0f);
                    newY = (short) ((sin(Angle / 200.0f) * 300.0f) * cos(Angle) * 100.0f);
                    break;
                case 6:
                    newX = (short) (cos(Angle) * 40000.0);
                    newY = (short) (sin(Angle) * 20000.0);
                    break;
                case 7:
                    newX = (short) rand.nextInt(65535);
                    if (rand.nextInt(2) == 0) {
                        newY = (short) ((int) (sin(Angle / 80.0) * 10000.0) + 15000);
                    } else {
                        newY = (short) (50000 - (int) (sin(Angle / 80.0) * 13000));
                    }
                    break;
                case 8:
//                    newX = (short) (cos(Angle / 2.0) * 40000.0);
//                    newY = (short) (sin(Angle) * 20000.0);
                    newX = (short) (sin(Angle / 2.0) * 40000.0);
                    newY = (short) (cos(Angle) * 20000.0);
                    break;
                case 9:
                    incrAngle2();
                    newX = (short) (sin(cos(Angle2 / 10.0) + (Angle / 500.0)) * 32000.0);
                    newY = (short) (cos(sin(Angle2 / 10.0) + (Angle / 500.0)) * 30000.0);
                    break;
                case 10:
                    incrAngle2();
                    newX = (short) (sin(cos(Angle2 / 5.0) + (Angle / 100.0)) * 32000.0);
                    newY = (short) (cos(sin(Angle2 / 5.0) + (Angle / 100.0)) * 30000.0);
                    break;
                case 11:
                    incrAngle2();
                    newX = (short) (sin(cos(Angle2 / 1000.0) + (Angle / 2.0)) * 32000.0);
                    newY = (short) (cos(sin(Angle2 / 1000.0) + (Angle / 2.0)) * 30000.0);
                    break;
                case 12:
                    if (Angle != 0.0) {
                        incrAngle2();
                        newX = (short) (sin(cos(Angle2 / 2.0) / (sqrt(abs(Angle)) / 10.0 + 1.0) + (Angle2 / 100.0)) * 32000.0);
                        newY = (short) (cos(sin(Angle2 / 2.0) / (sqrt(Angle) / 10.0 + 1.0) + (Angle2 / 100.0)) * 30000.0);
                    }
                    break;
                default:
                    newX = (short) (rand.nextInt(64000) - 32000);
                    newY = (short) (rand.nextInt(40000) - 20000);
            } // switch
        }
        star.setZ(MAX_DISTANCE);
        star.setX(newX);
        star.setY(newY);
    }

    private void incrAngle2() {
        Angle2 += Angle2Increment;
        if (Angle2 == 0xFFFF || Angle2 == 0) {
            Angle2Increment = -Angle2Increment;
        }
    }
    /**
     * Перерисовка звезд
     */
    public void render(ScreenBuffer buffer) {
        int width = buffer.getWidth();
        int height = buffer.getHeight();

        warpSpeed += warpVelocity;

        buffer.clear();

        // Отрисовываем с сортировкой по глубине
        stars.stream().sorted((e, k) -> k.getZ() - e.getZ()).forEach(star -> {
            if (!star.update(width, height, warpSpeed)) {
                genNewCoord(star);
            } else {
                star.render(buffer, baseColor);
            }
        });

        // не пора ли менять функцию генератора звезд?
        if (isChangeFunc) {
            changeTicks++;
            if (changeTicks > changeTime)
                starSetFunc(0);
        }
        //
        if (rand.nextInt(1000) == 1) {
            AngleVelocity = (float) (random() * 0.001f - 0.0005f);
        }
        AngleIncrement += AngleVelocity;
    }


    public void keyPressed(KeyEvent e) {
        char ch = e.getKeyChar();
        switch (ch) {
            case '+':
            case '=':
                warpSpeed++;
                warpVelocity = 0;
                break;
            case '-':
            case '_':
                warpSpeed--;
                warpVelocity = 0;
                break;
            case '0':
                starSetFunc(10);
                break;
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                starSetFunc(ch - '0');
                break;
            case '!':
            case '@':
            case '#':
            case '$':
                starSetFunc(ch - '!' + 11);
                break;
            case 'c':
            case 'C':
                starsReset();
                break;
            case 's':
            case 'S':
                AngleVelocity = random() * 0.01f - 0.005f;
                break;
            case '[':
                baseColor--;
                break;
            case ']':
                baseColor++;
                break;
            case '{':
                baseColor -= 72;
                break;
            case '}':
                baseColor += 72;
                break;
            case '`':
                isChangeFunc = !isChangeFunc;
                break;
        }
    }


}
