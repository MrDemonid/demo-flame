package mr.demonid.jukebox;


import mr.demonid.graphics.ScreenBuffer;

import java.awt.event.KeyEvent;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

import static java.lang.Math.random;


public class JukeBox {

    private final static int MAX_STARS = 1000;
    private final static int MAX_DISTANCE = 500;

    byte[] gamePalette = {
            0x00, 0x00, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x2A, 0x00, 0x00, 0x2A, 0x2A, 0x2A, 0x00, 0x00, 0x2A,
            0x00, 0x2A, 0x2A, 0x15, 0x00, 0x2A, 0x2A, 0x2A, 0x15, 0x15, 0x15, 0x15, 0x15, 0x3F, 0x15, 0x3F,
            0x15, 0x15, 0x3F, 0x3F, 0x3F, 0x15, 0x15, 0x3F, 0x15, 0x3F, 0x3F, 0x3F, 0x15, 0x3F, 0x3F, 0x3F,
            0x00, 0x00, 0x00, 0x05, 0x05, 0x05, 0x08, 0x08, 0x08, 0x0B, 0x0B, 0x0B, 0x0E, 0x0E, 0x0E, 0x11,
            0x11, 0x11, 0x14, 0x14, 0x14, 0x18, 0x18, 0x18, 0x1C, 0x1C, 0x1C, 0x20, 0x20, 0x20, 0x24, 0x24,
            0x24, 0x28, 0x28, 0x28, 0x2D, 0x2D, 0x2D, 0x32, 0x32, 0x32, 0x38, 0x38, 0x38, 0x3F, 0x3F, 0x3F,
            0x00, 0x00, 0x3F, 0x10, 0x00, 0x3F, 0x1F, 0x00, 0x3F, 0x2F, 0x00, 0x3F, 0x3F, 0x00, 0x3F, 0x3F,
            0x00, 0x2F, 0x3F, 0x00, 0x1F, 0x3F, 0x00, 0x10, 0x3F, 0x00, 0x00, 0x3F, 0x10, 0x00, 0x3F, 0x1F,
            0x00, 0x3F, 0x2F, 0x00, 0x3F, 0x3F, 0x00, 0x2F, 0x3F, 0x00, 0x1F, 0x3F, 0x00, 0x10, 0x3F, 0x00,
            0x00, 0x3F, 0x00, 0x00, 0x3F, 0x10, 0x00, 0x3F, 0x1F, 0x00, 0x3F, 0x2F, 0x00, 0x3F, 0x3F, 0x00,
            0x2F, 0x3F, 0x00, 0x1F, 0x3F, 0x00, 0x10, 0x3F, 0x1F, 0x1F, 0x3F, 0x27, 0x1F, 0x3F, 0x2F, 0x1F,
            0x3F, 0x37, 0x1F, 0x3F, 0x3F, 0x1F, 0x3F, 0x3F, 0x1F, 0x37, 0x3F, 0x1F, 0x2F, 0x3F, 0x1F, 0x27,
            0x3F, 0x1F, 0x1F, 0x3F, 0x27, 0x1F, 0x3F, 0x2F, 0x1F, 0x3F, 0x37, 0x1F, 0x3F, 0x3F, 0x1F, 0x37,
            0x3F, 0x1F, 0x2F, 0x3F, 0x1F, 0x27, 0x3F, 0x1F, 0x1F, 0x3F, 0x1F, 0x1F, 0x3F, 0x27, 0x1F, 0x3F,
            0x2F, 0x1F, 0x3F, 0x37, 0x1F, 0x3F, 0x3F, 0x1F, 0x37, 0x3F, 0x1F, 0x2F, 0x3F, 0x1F, 0x27, 0x3F,
            0x2D, 0x2D, 0x3F, 0x31, 0x2D, 0x3F, 0x36, 0x2D, 0x3F, 0x3A, 0x2D, 0x3F, 0x3F, 0x2D, 0x3F, 0x3F,
            0x2D, 0x3A, 0x3F, 0x2D, 0x36, 0x3F, 0x2D, 0x31, 0x3F, 0x2D, 0x2D, 0x3F, 0x31, 0x2D, 0x3F, 0x36,
            0x2D, 0x3F, 0x3A, 0x2D, 0x3F, 0x3F, 0x2D, 0x3A, 0x3F, 0x2D, 0x36, 0x3F, 0x2D, 0x31, 0x3F, 0x2D,
            0x2D, 0x3F, 0x2D, 0x2D, 0x3F, 0x31, 0x2D, 0x3F, 0x36, 0x2D, 0x3F, 0x3A, 0x2D, 0x3F, 0x3F, 0x2D,
            0x3A, 0x3F, 0x2D, 0x36, 0x3F, 0x2D, 0x31, 0x3F, 0x00, 0x00, 0x1C, 0x07, 0x00, 0x1C, 0x0E, 0x00,
            0x1C, 0x15, 0x00, 0x1C, 0x1C, 0x00, 0x1C, 0x1C, 0x00, 0x15, 0x1C, 0x00, 0x0E, 0x1C, 0x00, 0x07,
            0x1C, 0x00, 0x00, 0x1C, 0x07, 0x00, 0x1C, 0x0E, 0x00, 0x1C, 0x15, 0x00, 0x1C, 0x1C, 0x00, 0x15,
            0x1C, 0x00, 0x0E, 0x1C, 0x00, 0x07, 0x1C, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x1C, 0x07, 0x00, 0x1C,
            0x0E, 0x00, 0x1C, 0x15, 0x00, 0x1C, 0x1C, 0x00, 0x15, 0x1C, 0x00, 0x0E, 0x1C, 0x00, 0x07, 0x1C,
            0x0E, 0x0E, 0x1C, 0x11, 0x0E, 0x1C, 0x15, 0x0E, 0x1C, 0x18, 0x0E, 0x1C, 0x1C, 0x0E, 0x1C, 0x1C,
            0x0E, 0x18, 0x1C, 0x0E, 0x15, 0x1C, 0x0E, 0x11, 0x1C, 0x0E, 0x0E, 0x1C, 0x11, 0x0E, 0x1C, 0x15,
            0x0E, 0x1C, 0x18, 0x0E, 0x1C, 0x1C, 0x0E, 0x18, 0x1C, 0x0E, 0x15, 0x1C, 0x0E, 0x11, 0x1C, 0x0E,
            0x0E, 0x1C, 0x0E, 0x0E, 0x1C, 0x11, 0x0E, 0x1C, 0x15, 0x0E, 0x1C, 0x18, 0x0E, 0x1C, 0x1C, 0x0E,
            0x18, 0x1C, 0x0E, 0x15, 0x1C, 0x0E, 0x11, 0x1C, 0x14, 0x14, 0x1C, 0x16, 0x14, 0x1C, 0x18, 0x14,
            0x1C, 0x1A, 0x14, 0x1C, 0x1C, 0x14, 0x1C, 0x1C, 0x14, 0x1A, 0x1C, 0x14, 0x18, 0x1C, 0x14, 0x16,
            0x1C, 0x14, 0x14, 0x1C, 0x16, 0x14, 0x1C, 0x18, 0x14, 0x1C, 0x1A, 0x14, 0x1C, 0x1C, 0x14, 0x1A,
            0x1C, 0x14, 0x18, 0x1C, 0x14, 0x16, 0x1C, 0x14, 0x14, 0x1C, 0x14, 0x14, 0x1C, 0x16, 0x14, 0x1C,
            0x18, 0x14, 0x1C, 0x1A, 0x14, 0x1C, 0x1C, 0x14, 0x1A, 0x1C, 0x14, 0x18, 0x1C, 0x14, 0x16, 0x1C,
            0x00, 0x00, 0x10, 0x04, 0x00, 0x10, 0x08, 0x00, 0x10, 0x0C, 0x00, 0x10, 0x10, 0x00, 0x10, 0x10,
            0x00, 0x0C, 0x10, 0x00, 0x08, 0x10, 0x00, 0x04, 0x10, 0x00, 0x00, 0x10, 0x04, 0x00, 0x10, 0x08,
            0x00, 0x10, 0x0C, 0x00, 0x10, 0x10, 0x00, 0x0C, 0x10, 0x00, 0x08, 0x10, 0x00, 0x04, 0x10, 0x00,
            0x00, 0x10, 0x00, 0x00, 0x10, 0x04, 0x00, 0x10, 0x08, 0x00, 0x10, 0x0C, 0x00, 0x10, 0x10, 0x00,
            0x0C, 0x10, 0x00, 0x08, 0x10, 0x00, 0x04, 0x10, 0x08, 0x08, 0x10, 0x0A, 0x08, 0x10, 0x0C, 0x08,
            0x10, 0x0E, 0x08, 0x10, 0x10, 0x08, 0x10, 0x10, 0x08, 0x0E, 0x10, 0x08, 0x0C, 0x10, 0x08, 0x0A,
            0x10, 0x08, 0x08, 0x10, 0x0A, 0x08, 0x10, 0x0C, 0x08, 0x10, 0x0E, 0x08, 0x10, 0x10, 0x08, 0x0E,
            0x10, 0x08, 0x0C, 0x10, 0x08, 0x0A, 0x10, 0x08, 0x08, 0x10, 0x08, 0x08, 0x10, 0x0A, 0x08, 0x10,
            0x0C, 0x08, 0x10, 0x0E, 0x08, 0x10, 0x10, 0x08, 0x0E, 0x10, 0x08, 0x0C, 0x10, 0x08, 0x0A, 0x10,
            0x0B, 0x0B, 0x10, 0x0C, 0x0B, 0x10, 0x0D, 0x0B, 0x10, 0x0F, 0x0B, 0x10, 0x10, 0x0B, 0x10, 0x10,
            0x0B, 0x0F, 0x10, 0x0B, 0x0D, 0x10, 0x0B, 0x0C, 0x10, 0x0B, 0x0B, 0x10, 0x0C, 0x0B, 0x10, 0x0D,
            0x0B, 0x10, 0x0F, 0x0B, 0x10, 0x10, 0x0B, 0x0F, 0x10, 0x0B, 0x0D, 0x10, 0x0B, 0x0C, 0x10, 0x0B,
            0x0B, 0x10, 0x0B, 0x0B, 0x10, 0x0C, 0x0B, 0x10, 0x0D, 0x0B, 0x10, 0x0F, 0x0B, 0x10, 0x10, 0x0B,
            0x0F, 0x10, 0x0B, 0x0D, 0x10, 0x0B, 0x0C, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};


    Random rand = new Random(System.currentTimeMillis());


    private double Angle;
    private double AngleIncrement;   // приращение угла на каждом шаге
    private double AngleVelocity;    // приращение инкремента

    private int warpSpeed;        // скорость приближения звезд
    private int warpVelocity;     // приращение скорости приближения

    private int changeTicks;      // отсчитанное время до смены функции генерации звезд
    private int changeTime;       // время до смены функции генерации звезд

    private boolean isChangeFunc;   // флаг разрешения смены функции генерации звезд
    //     0 - смена функции запрещена
    //     1 - разрешена
    private int nGenFunc;           // номер текущей функции генерации звезд

    private byte baseColor;        // цвет новоиспеченных звезд

    private final List<Star> stars = new ArrayList<>(MAX_STARS);
    //    private final Star[] stars = new Star[MAX_STARS];


    public JukeBox() {
        starInitialize();
    }


    public byte[] getGamePalette() {
        return gamePalette;
    }

    private void starInitialize() {
        isChangeFunc = true;        // разрешаем смену функций генерации звезд
        starsReset();
        starInitStars();
        starSetFunc(2);
    }

    private void starSetFunc(int func) {
        changeTicks = 0;
        changeTime = rand.nextInt(1000);

        if (func <= 0) {
            //nGenFunc = random(15);
            nGenFunc = rand.nextInt(6);     // 0..5
        } else {
            if (func > 14)
                func = 14;
            nGenFunc = func;
        }
        if (nGenFunc == 1)
            AngleIncrement = 0.1f;
        if (AngleIncrement > 2.2f)
            AngleIncrement = 0.1f;
    }

    /*
        Сброс настроек генератора звезд
     */
    private void starsReset() {
        Angle = 0.0f;
        AngleIncrement = 0.1f;
        AngleVelocity = 0.0001f;
        baseColor = 32;
        warpSpeed = 2;
        warpVelocity = 0;
    }

    /*
        Инициализация массива звезд
     */
    private void starInitStars() {
        for (int i = 0; i < MAX_STARS; i++) {
            stars.add(new Star(rand.nextInt(64000) - 32000, rand.nextInt(40000) - 20000, i + 1));
        }
    }

    /*
        Перерождение ушедшей с поля зрения звезды - просто даем новые координаты.
    */
    void genNewCoord(Star star) {
        double newX;
        double newY;

        if (nGenFunc == 0) {
            newX = rand.nextInt(64000) - 32000;
            newY = rand.nextInt(40000) - 20000;
        } else {
            Angle += AngleIncrement;
            switch (nGenFunc) {
                case 1:
                    newX = Math.cos(Angle / 30.0f) * 20000.0f;
                    newY = rand.nextInt(40000) - 20000;
                    break;
                case 2:
                    newX = Math.sin(Angle) * 20000.0f;
                    newY = Math.cos(Angle) * 20000.0f;
                    break;
                case 3:
                    newX = (Math.sin(Angle * 15.0f) * 100.0f) * ((int) (Angle / 6.0f) % 200);
                    newY = (Math.cos(Angle * 15.0f) * 100.0f) * ((int) (Angle / 6.0f) % 200);
                    break;

                case 4:
                    newX = Math.cos(Angle / 60.0f) * 20000.0f;
                    newY = (Math.sin(Angle) * (long) (Math.cos(Angle / 200.0f) * 300.0f)) * 100.0f;
                    break;

                case 5:
                    newX = Math.cos(Angle / 2.0f) * 20000.0f;
                    newY = (long) (Math.sin(Angle / 200.0f) * 300.0f) * Math.cos(Angle) * 100.0f;
                    break;

                default:
                    newX = rand.nextInt(64000) - 32000;
                    newY = rand.nextInt(40000) - 20000;
            } // switch
        }
        star.setZ(MAX_DISTANCE);
        star.setX((int) newX);
        star.setY((int) newY);
    }

    /**
     * Перерисовка звезд
     */
    public void render(ScreenBuffer buffer) {
        int width = buffer.getWidth();
        int height = buffer.getHeight();

        warpSpeed += warpVelocity;

        buffer.clear();

        // Отрисовываем с сортировкой по глубине
        stars.stream().sorted((e, k) -> k.getZ() - e.getZ()).forEach(star -> {
            if (!star.update(width, height, warpSpeed)) {
                genNewCoord(star);
            } else {
                star.render(buffer, baseColor);
            }
        });

        // не пора ли менять функцию генератора звезд?
        if (isChangeFunc) {
            changeTicks++;
            if (changeTicks > changeTime)
                starSetFunc(0);
        }
        //
        if (rand.nextInt(1000) == 1) {
            AngleVelocity = (float) (random() * 0.001f - 0.0005f);
        }
        AngleIncrement += AngleVelocity;
    }


    public void keyPressed(KeyEvent e) {
        char ch = e.getKeyChar();
        switch (ch) {
            case '+':
            case '=':
                warpSpeed++;
                warpVelocity = 0;
                break;
            case '-':
            case '_':
                warpSpeed--;
                warpVelocity = 0;
                break;
            case '0':
                starSetFunc(10);
                break;
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                starSetFunc(ch - '0');
                break;
            case '!':
            case '@':
            case '#':
            case '$':
                starSetFunc(ch - '!' + 11);
                break;
            case 'c':
            case 'C':
                starsReset();
                break;
            case 's':
            case 'S':
                AngleVelocity = random() * 0.01f - 0.005f;
                break;
            case '[':
                baseColor--;
                break;
            case ']':
                baseColor++;
                break;
            case '{':
                baseColor -= 72;
                break;
            case '}':
                baseColor += 72;
                break;
            case '`':
                isChangeFunc = !isChangeFunc;
                break;
        }
    }


}
